<!DOCTYPE html><html lang="en"><head><title>adt/BinomialHeap/LazyBinomialHeap</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../"><meta name="groc-document-path" content="adt/BinomialHeap/LazyBinomialHeap"><meta name="groc-project-path" content="js/src/adt/BinomialHeap/LazyBinomialHeap.js"><meta name="groc-github-url" content="https://github.com/aureooms/js-heap-spec"><link rel="stylesheet" type="text/css" media="all" href="../../assets/style.css"><script type="text/javascript" src="../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/aureooms/js-heap-spec/blob/master/js/src/adt/BinomialHeap/LazyBinomialHeap.js">js/src/adt/BinomialHeap/LazyBinomialHeap.js</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> __LazyBinomialHeap__ = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> BinomialTree </span>) </span>{

	<span class="hljs-keyword">var</span> lazy_binomial_heap_push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> lazy, tree, rank </span>)</span>{

		<span class="hljs-keyword">var</span> i, sequence;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>lightweight binomial heap containing a unique tree</p></div></div><div class="code"><div class="wrapper">		sequence = [];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>offset tree by its rank</p></div></div><div class="code"><div class="wrapper">		i = rank;

		<span class="hljs-keyword">while</span> ( i-- ) {
			sequence.push( <span class="hljs-literal">null</span> );
		}

		sequence.push( tree );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>do not merge the generated sequence immediately</p></div></div><div class="code"><div class="wrapper">		lazy.push( sequence );

	};

	<span class="hljs-keyword">var</span> merge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> predicate, list, other </span>) </span>{

		<span class="hljs-keyword">var</span> i, len, carry;

		<span class="hljs-keyword">if</span> ( other.length === <span class="hljs-number">0</span> ) {
			<span class="hljs-keyword">return</span>;
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>merging two binomial heaps is like
adding two little endian integers
so, we first make sure that we have
enough place to store the result</p></div></div><div class="code"><div class="wrapper">		i = other.length - list.length;

		<span class="hljs-keyword">while</span> ( i --&gt; <span class="hljs-number">0</span> ) {
			list.push( <span class="hljs-literal">null</span> );
		}

		carry = <span class="hljs-literal">null</span>;

		len = list.length;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>remember len &gt;= other.length</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt; len ; ++i ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>other[i] can be either null or not
list[i] can be either null or not
carry can be either null or not
--&gt; 2^3 = 8 possibilities</p>
<h2 id="-null---otheri--listi--carry">   null ? | other[i] | list[i] | carry</h2>
<pre><code>(0)   |    no    |     no  |   no
(1)   |    no    |     no  |  yes
(2)   |    no    |    yes  |   no
(3)   |    no    |    yes  |  yes
(4)   |   yes    |     no  |   no
(5)   |   yes    |     no  |  yes
(6)   |   yes    |    yes  |   no
(7)   |   yes    |    yes  |  yes</code></pre></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( i &gt;= other.length || other[i] === <span class="hljs-literal">null</span> ) {

				<span class="hljs-keyword">if</span> ( carry !== <span class="hljs-literal">null</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>(6) other[i] = null and list[i] = null and carry != null
--&gt; put carry in current cell</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">if</span> ( list[i] === <span class="hljs-literal">null</span> ) {
						list[i] = carry;
						carry = <span class="hljs-literal">null</span>;
					}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>(4) other[i] = null and list[i] != null and carry != null
--&gt; merge carry with current cell</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">else</span> {
						carry = carry.merge( predicate, list[i] );
						list[i] = <span class="hljs-literal">null</span>;
					}

				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We do not need to do anything for</p>
<h1 id="those-2-cases-carry-and-otheri-are-null">those 2 cases (carry and other[i] are null).</h1>
<p>(5) other[i] = null and list[i] != null and carry = null
(7) other[i] = null and list[i] = null and carry = null</p></div></div><div class="code"><div class="wrapper">			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>(0) other[i] != null and list[i] != null and carry != null
(2) other[i] != null and list[i] = null and carry != null
--&gt; merge carry with other[i]</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( carry !== <span class="hljs-literal">null</span> ) {

				carry = carry.merge( predicate, other[i] );

			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>(1) other[i] != null and list[i] != null and carry = null
--&gt; merge current cell with other[i]</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( list[i] !== <span class="hljs-literal">null</span> ) {

				carry = list[i].merge( predicate, other[i] );
				list[i] = <span class="hljs-literal">null</span>;

			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>(3) other[i] != null and list[i] = null and carry = null
--&gt; put other[i] in list</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">else</span> {

				list[i] = other[i];

			}

		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>do not forget to append last carry</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( carry !== <span class="hljs-literal">null</span> ) {
			list.push( carry );
		}

	};


	<span class="hljs-keyword">var</span> lazy_binomial_heap_pop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> predicate, list, lazy </span>) </span>{

		<span class="hljs-keyword">var</span> i, j, len, opt, item, candidate, orphan;

		len = lazy.length;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>amortized merge of
stored values</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt; len ; ++i ) {
			merge( predicate, list, lazy[i] );
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>clean up lazy list</p></div></div><div class="code"><div class="wrapper">		lazy.splice( <span class="hljs-number">0</span> );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>standard O(log n) optimum search method</p></div></div><div class="code"><div class="wrapper">		len = list.length;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>there MUST be at least one
non null element in this list
we look for the first one</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span> ; j &lt; len - <span class="hljs-number">1</span> &amp;&amp; list[j] === <span class="hljs-literal">null</span> ; ++j ) ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>here j is necessarily &lt; len
and list[j] is non null</p></div></div><div class="code"><div class="wrapper">		i = j;
		opt = list[j].value;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we lookup remaining elements to see if there
is not a better candidate</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( ++j ; j &lt; len ; ++j ) {

			item = list[j];

			<span class="hljs-keyword">if</span> ( item !== <span class="hljs-literal">null</span> ) {

				candidate = item.value;

				<span class="hljs-keyword">if</span> ( predicate( candidate, opt ) &lt; <span class="hljs-number">0</span> ) {

					i = j;
					opt = candidate;

				}

			}

		}

		orphan = list[i].children;
		list[i] = <span class="hljs-literal">null</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we just removed the ith element
if list[i] is the last cell
of list we can drop it</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( i === len - <span class="hljs-number">1</span> ) {
			list.pop();
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we store the children in the
lazy list</p></div></div><div class="code"><div class="wrapper">		lazy.push( orphan );

		<span class="hljs-keyword">return</span> opt;
	};

	<span class="hljs-keyword">var</span> LazyBinomialHeap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> predicate </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>the predicate to use to compare values</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.predicate = predicate;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>number of elements in this heap</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.length = <span class="hljs-number">0</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>list of binomial trees</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.list = [];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>list of binomial heaps waiting to be merged</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.lazy = [];

	};


	LazyBinomialHeap.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.length === <span class="hljs-number">0</span> ) {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
		}

		--<span class="hljs-keyword">this</span>.length;

		<span class="hljs-keyword">return</span> lazy_binomial_heap_pop( <span class="hljs-keyword">this</span>.predicate, <span class="hljs-keyword">this</span>.list, <span class="hljs-keyword">this</span>.lazy );

	};

	LazyBinomialHeap.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{

		++<span class="hljs-keyword">this</span>.length;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>push a new tree of rank 0</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">return</span> lazy_binomial_heap_push( <span class="hljs-keyword">this</span>.lazy, <span class="hljs-keyword">new</span> BinomialTree( value, [] ), <span class="hljs-number">0</span> );

	};


	LazyBinomialHeap.prototype.merge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> other </span>) </span>{
		<span class="hljs-keyword">var</span> i;
		<span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt; other.lazy.length ; ++i ) {
			<span class="hljs-keyword">this</span>.lazy.push( other.lazy[i] );
		}
		<span class="hljs-keyword">this</span>.lazy.push( other.list );
		<span class="hljs-keyword">this</span>.length += other.length;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	};

	<span class="hljs-keyword">return</span> LazyBinomialHeap;
};

exports.__LazyBinomialHeap__ = __LazyBinomialHeap__;</div></div></div></div></body></html>